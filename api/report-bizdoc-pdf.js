// Clean, robust BizDoc PDF (no logos). Safe page breaks, numbers, progress bars, bar chart.
export default async function handler(req, res) {
  try {
    res.setHeader("Access-Control-Allow-Origin","*");
    res.setHeader("Access-Control-Allow-Methods","POST,OPTIONS");
    res.setHeader("Access-Control-Allow-Headers","Content-Type, Authorization");
    if (req.method === "OPTIONS") return res.status(204).end();
    if (req.method !== "POST") return res.status(405).json({ ok:false, error:"Use POST" });

    // Dynamic import avoids ESM/CJS issues on Vercel
    const { PDFDocument, StandardFonts, rgb } = await import("pdf-lib");

    const body = await readBody(req);
    const analysis = body?.analysis;
    const brand = body?.brand || { title: "BizDoc Analysis Report", company: "BizDoc" };
    if (!analysis || typeof analysis !== "object")
      return res.status(400).json({ ok:false, error:"Missing 'analysis' JSON" });

    // --- Setup
    const A4 = [595.28, 841.89];
    const pdf = await PDFDocument.create();
    let page = pdf.addPage(A4);
    const { width, height } = page.getSize();
    const margin = 48;
    const colW = width - margin*2;

    const font = await pdf.embedFont(StandardFonts.Helvetica);
    const bold = await pdf.embedFont(StandardFonts.HelveticaBold);

    let y = height - margin;

    // --- Drawing helpers
    const T = (f, size, x, yy, text, color=rgb(0,0,0)) =>
      page.drawText(String(text ?? ""), { x, y: yy, size, font: f, color });

    const HR = (yy) => page.drawRectangle({ x: margin, y: yy-0.5, width: colW, height: 0.8, color: rgb(0.85,0.85,0.85) });

    const wrap = (f, size, x, yy, w, text) => {
      const words = String(text ?? "").split(/\s+/);
      let line = "", cur = yy;
      for (const w of words) {
        const t = (line ? line+" " : "") + w;
        if (f.widthOfTextAtSize(t, size) > w) {
          page.drawText(line, { x, y: cur, size, font: f });
          cur -= size + 4; line = w;
        } else { line = t; }
      }
      if (line) { page.drawText(line, { x, y: cur, size, font: f }); cur -= size + 4; }
      return cur;
    };

    const ensureSpace = (need=100) => {
      if (y - need < margin + 60) {
        page = pdf.addPage(A4);
        y = height - margin;
        header(false);
      }
    };

    const header = (first=true) => {
      T(bold, 18, margin, y, brand.title); y -= 12;
      HR(y); y -= 20;
      if (first) {
        const metaRight = `${(analysis.docType||"DOCUMENT").toString().toUpperCase()}  |  ${today()}`;
        T(font, 10, margin, y, "Generated by BizDoc"); 
        T(font, 10, width - margin - w(font,10,metaRight), y, metaRight); 
        y -= 16;
      }
    };

    const section = (name) => { ensureSpace(40); T(bold, 12, margin, y, name); y -= 14; };

    const progress = (label, value01) => {
      // value01 in [0..1]
      const v = clamp01(value01);
      const H = 10, W = Math.min(280, colW);
      const yBar = y - H;
      T(font, 11, margin, y, `${label}: ${pct(v)}`); 
      page.drawRectangle({ x: margin, y: yBar, width: W, height: H, borderColor: rgb(0.8,0.8,0.8), borderWidth: 1, color: rgb(1,1,1) });
      page.drawRectangle({ x: margin, y: yBar, width: W * v, height: H, color: rgb(0.2,0.2,0.2) });
      y -= H + 10;
    };

    const barsChart = (title, items) => {
      const data = (Array.isArray(items) ? items : []).map(b => ({ 
        label: safeStr(b?.label).slice(0,12), 
        value: safeNum(b?.value) 
      })).filter(b => isFinite(b.value));
      if (!data.length) return;

      ensureSpace(180);
      T(bold, 12, margin, y, title); y -= 12;

      // Frame
      const C = { x: margin, y: y-140, w: colW, h: 140, pad: 16 };
      page.drawRectangle({ x: C.x, y: C.y, width: C.w, height: C.h, borderColor: rgb(0.8,0.8,0.8), borderWidth: 1, color: rgb(1,1,1) });

      const innerW = C.w - C.pad*2, innerH = C.h - C.pad*2;
      const max = Math.max(...data.map(d => d.value), 1);
      const n = data.length;
      const step = innerW / n;
      const bw = Math.max(8, step * 0.6);
      let bx = C.x + C.pad + step*0.2;
      for (const d of data.slice(0, 24)) {
        const hBar = (d.value / max) * innerH;
        page.drawRectangle({ x: bx, y: C.y + C.pad, width: bw, height: hBar, color: rgb(0.2,0.2,0.2) });
        page.drawText(String(d.label), { x: bx, y: C.y + 4, size: 8, font, rotate: undefined });
        bx += step;
      }
      y = C.y - 10;
    };

    const w = (f, size, text) => f.widthOfTextAtSize(String(text ?? ""), size);

    // --- Header
    header(true);

    // --- Summary
    section("Summary");
    y = wrap(font, 12, margin, y, colW, analysis.summary || "-");
    y -= 6;

    // --- Financial Health (with progress bars)
    const fh = analysis.financialHealth || {};
    section("Financial Health");
    progress("Profitability", score01(fh.profitabilityScore));
    progress("Liquidity",     score01(fh.liquidityScore));
    progress("Concentration Risk (lower is better)", 1 - score01(fh.concentrationRiskScore));
    if (Array.isArray(fh.anomalyFlags) && fh.anomalyFlags.length) {
      y = wrap(font, 11, margin, y, colW, "Anomalies: " + fh.anomalyFlags.join("; "));
      y -= 4;
    }
    y = wrap(font, 11, margin, y, colW, "Rationale: " + safeStr(fh.rationale));
    y -= 8;

    // --- Key Amounts
    const amounts = Array.isArray(analysis.amounts) ? analysis.amounts : [];
    if (amounts.length) {
      section("Key Amounts");
      for (const a of amounts.slice(0, 10)) {
        const line = `${safeStr(a?.label || "Amount")}: ${fmtNum(a?.value)} ${safeStr(a?.currency)}`;
        y = wrap(font, 11, margin, y, colW, line) - 2;
        ensureSpace(22);
      }
      y -= 6;
    }

    // --- Risks
    const risks = Array.isArray(analysis.risks) ? analysis.risks : [];
    section("Risks");
    if (risks.length) {
      for (const r of risks.slice(0, 12)) {
        const line = `• [${safeStr(r?.severity).toUpperCase()}] ${safeStr(r?.risk)} — ${safeStr(r?.mitigation)}`;
        y = wrap(font, 11, margin, y, colW, line) - 2;
        ensureSpace(22);
      }
    } else {
      y = wrap(font, 11, margin, y, colW, "No major risks identified.") - 2;
    }
    y -= 6;

    // --- Actions
    const actions = Array.isArray(analysis.actions) ? analysis.actions : [];
    section("Actions");
    if (actions.length) {
      for (const a of actions.slice(0, 12)) {
        const line = `• [P${safeInt(a?.priority)}] ${safeStr(a?.action)}${a?.owner ? " | Owner: "+safeStr(a.owner) : ""}${isFinite(a?.dueDays)? " | Due: "+a.dueDays+"d" : ""}`;
        y = wrap(font, 11, margin, y, colW, line) - 2;
        ensureSpace(22);
      }
    } else {
      y = wrap(font, 11, margin, y, colW, "No immediate actions suggested.") - 2;
    }
    y -= 8;

    // --- Charts (bars)
    const bars = analysis?.charts?.bars;
    if (Array.isArray(bars) && bars.length) {
      barsChart("Chart: Bars", bars);
    }

    // --- Footer
    HR(60);
    T(font, 10, margin, 46, `${brand.company || "BizDoc"} • Confidence: ${pct(analysis.confidence)}`);
    T(font, 10, width - margin - w(font, 10, today()), 46, today());

    // --- Output
    const bytes = await pdf.save();
    res.setHeader("Content-Type", "application/pdf");
    res.setHeader("Content-Disposition", 'attachment; filename="bizdoc_report.pdf"');
    return res.status(200).send(Buffer.from(bytes));
  } catch (e) {
    return res.status(500).json({ ok:false, error: String(e?.message || e) });
  }
}

/* ---------- utils ---------- */
function clamp01(x){ const n = Number(x); return isFinite(n) ? Math.max(0, Math.min(1, n)) : 0; }
function score01(s){ const n = Number(s); return isFinite(n) ? Math.max(0, Math.min(1, n/5)) : 0; }
function pct(n){ return isFinite(n) ? Math.round(n*100)+"%" : "-"; }
function fmtNum(n){ const v = Number(n); return isFinite(v) ? new Intl.NumberFormat("en-US",{maximumFractionDigits:2}).format(v) : "-"; }
function safeInt(n){ const v = parseInt(n,10); return isFinite(v) ? v : "-"; }
function safeNum(n){ const v = Number(n); return isFinite(v) ? v : 0; }
function safeStr(s){ return (s==null) ? "" : String(s); }
function today(){ return new Date().toISOString().slice(0,10); }

async function readBody(req){
  const chunks=[]; for await (const c of req) chunks.push(c);
  try { return JSON.parse(Buffer.concat(chunks).toString("utf8")||"{}"); } catch { return {}; }
}
