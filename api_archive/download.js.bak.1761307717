import { PDFDocument, StandardFonts, rgb } from "pdf-lib";

// Ensure we always send a valid PDF stream, never JSON unless failing
export default async function handler(req, res) {
  try {
    if (req.method !== "POST") {
      res.setHeader("Allow", "POST");
      return res.status(405).json({ ok: false, error: "Method Not Allowed" });
    }

    // Collect JSON body (Vercel Node functions do not auto-parse)
    const chunks = [];
    await new Promise((resolve, reject) => {
      req.on("data", (c) => chunks.push(Buffer.isBuffer(c) ? c : Buffer.from(c)));
      req.on("end", resolve);
      req.on("error", reject);
    });

    const raw = Buffer.concat(chunks).toString("utf8").trim() || "{}";
    let payload;
    try {
      payload = JSON.parse(raw);
    } catch (e) {
      return res.status(400).json({ ok: false, error: "Invalid JSON body" });
    }

    const type = (payload.type || "pdf").toLowerCase();
    const filenameBase = String(payload.filename || payload.filenameBase || "analysis").replace(/[^\w.-]+/g, "_");
    const analysis = payload.analysis || {};

    // TXT/DOCX pass-throughs preserved (your app may already handle these elsewhere)
    if (type === "txt") {
      const text = renderPlainText(analysis);
      res.setHeader("Content-Type", "text/plain; charset=utf-8");
      res.setHeader("Content-Disposition", `attachment; filename="${filenameBase}.txt"`);
      return res.status(200).send(text);
    }

    if (type === "docx") {
      // Minimal DOCX fallback: wrap TXT into .docx if your older logic is removed.
      // For now, return text as .docx-compatible plain text to avoid breaking flows.
      const text = renderPlainText(analysis);
      res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.wordprocessingml.document");
      res.setHeader("Content-Disposition", `attachment; filename="${filenameBase}.docx"`);
      return res.status(200).send(Buffer.from(text, "utf8"));
    }

    // === PDF path ===
    const pdfDoc = await PDFDocument.create();
    const page = pdfDoc.addPage([595.28, 841.89]); // A4 in points
    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const fontBold = await pdfDoc.embedFont(StandardFonts.Helvetica);

    const marginX = 50;
    let y = 800;

    // Helpers
    const drawLine = (txt, size = 12, bold = false) => {
      const f = bold ? fontBold : font;
      const wrapped = wrapText(txt ?? "", f, size, 595.28 - marginX * 2);
      for (const line of wrapped) {
        if (y < 60) { // new page
          const p = pdfDoc.addPage([595.28, 841.89]);
          y = 800;
          p.setFont(f);
          p.setFontSize(size);
          p.drawText(line, { x: marginX, y, color: rgb(0, 0, 0) });
          y -= size + 4;
          continue;
        }
        page.setFont(f);
        page.setFontSize(size);
        page.drawText(line, { x: marginX, y, color: rgb(0, 0, 0) });
        y -= size + 4;
      }
      y -= 6; // extra spacing after a block
    };

    // Content
    drawLine(analysis.title || "Document Analysis", 18, true);
    if (analysis.executive_summary) {
      drawLine("Executive Summary", 14, true);
      drawLine(analysis.executive_summary, 12);
    }

    if (Array.isArray(analysis.key_findings) && analysis.key_findings.length) {
      drawLine("Key Findings", 14, true);
      for (const kf of analysis.key_findings) {
        drawLine(`• ${kf.label || ""}: ${kf.detail || ""}`, 12);
      }
    }

    if (Array.isArray(analysis.metrics) && analysis.metrics.length) {
      drawLine("Metrics", 14, true);
      for (const m of analysis.metrics) {
        const v = m.value != null ? m.value : "";
        const u = m.unit ? ` ${m.unit}` : "";
        drawLine(`• ${m.name || ""}: ${v}${u}`, 12);
      }
    }

    if (Array.isArray(analysis.risks) && analysis.risks.length) {
      drawLine("Risks & Mitigations", 14, true);
      for (const r of analysis.risks) {
        drawLine(`• Risk: ${r.risk || ""}`, 12, true);
        drawLine(`  Mitigation: ${r.mitigation || ""}`, 12);
      }
    }

    if (Array.isArray(analysis.recommendations) && analysis.recommendations.length) {
      drawLine("Recommendations", 14, true);
      for (const rec of analysis.recommendations) {
        drawLine(`• ${rec}`, 12);
      }
    }

    // Finalize
    const pdfBytes = await pdfDoc.save(); // Uint8Array with %PDF- header
    res.setHeader("Content-Type", "application/pdf");
    res.setHeader("Content-Disposition", `attachment; filename="${filenameBase}.pdf"`);
    res.status(200).send(Buffer.from(pdfBytes)); // ensure Node Buffer, not string
  } catch (err) {
    console.error("download handler error:", err);
    res.status(500).json({ ok: false, error: String(err && err.message || err) });
  }
}

function wrapText(text, font, size, maxWidth) {
  const words = String(text).split(/\s+/);
  const lines = [];
  let line = "";
  for (const w of words) {
    const test = line ? line + " " + w : w;
    const width = font.widthOfTextAtSize(test, size);
    if (width > maxWidth && line) {
      lines.push(line);
      line = w;
    } else {
      line = test;
    }
  }
  if (line) lines.push(line);
  return lines;
}

function renderPlainText(analysis) {
  const parts = [];
  parts.push(`# ${analysis?.title || "Document Analysis"}`);
  if (analysis?.executive_summary) {
    parts.push("\nExecutive Summary:\n" + analysis.executive_summary);
  }
  if (Array.isArray(analysis?.key_findings)) {
    parts.push("\nKey Findings:");
    for (const kf of analysis.key_findings) parts.push(`- ${kf.label || ""}: ${kf.detail || ""}`);
  }
  if (Array.isArray(analysis?.metrics)) {
    parts.push("\nMetrics:");
    for (const m of analysis.metrics) {
      const u = m.unit ? ` ${m.unit}` : "";
      parts.push(`- ${m.name || ""}: ${m.value ?? ""}${u}`);
    }
  }
  if (Array.isArray(analysis?.risks)) {
    parts.push("\nRisks & Mitigations:");
    for (const r of analysis.risks) {
      parts.push(`- Risk: ${r.risk || ""}`);
      parts.push(`  Mitigation: ${r.mitigation || ""}`);
    }
  }
  if (Array.isArray(analysis?.recommendations)) {
    parts.push("\nRecommendations:");
    for (const rec of analysis.recommendations) parts.push(`- ${rec}`);
  }
  return parts.join("\n");
}
